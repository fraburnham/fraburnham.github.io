<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-07-11 Mon 08:09 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Frank Burnham" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org72e1b85">1. Hello <code>chrdev</code></a>
<ul>
<li><a href="#orgff5707c">1.1. Loading and Unloading the Module</a>
<ul>
<li><a href="#orgf017051">1.1.1. Structs and Macros</a></li>
<li><a href="#orgabe7f47">1.1.2. Major Number Parameter</a></li>
<li><a href="#org801bfd5">1.1.3. Loading</a></li>
<li><a href="#org907b85d">1.1.4. Unloading</a></li>
</ul>
</li>
<li><a href="#org0967ab0">1.2. Opening and Closing a Device</a>
<ul>
<li><a href="#org4ffaed9">1.2.1. Opening</a></li>
<li><a href="#orgd929f89">1.2.2. Closing</a></li>
</ul>
</li>
<li><a href="#orgc51929f">1.3. Reading and Writing Devices</a>
<ul>
<li><a href="#org81366d3">1.3.1. Reading</a></li>
<li><a href="#org970cc72">1.3.2. Writing</a></li>
</ul>
</li>
<li><a href="#orgdadf6be">1.4. <span class="todo TODO">TODO</span> Building the Module</a>
<ul>
<li><a href="#org83fbfda">1.4.1. <span class="todo TODO">TODO</span> <code>Makefile</code></a></li>
</ul>
</li>
<li><a href="#org81f40e2">1.5. <span class="todo TODO">TODO</span> Using It!</a>
<ul>
<li><a href="#orgf784eb6">1.5.1. <span class="todo TODO">TODO</span> <code>hello-dev-load.sh</code></a></li>
<li><a href="#orge7b4fcb">1.5.2. <span class="todo TODO">TODO</span> <code>hello-dev-unload.sh</code></a></li>
<li><a href="#org9163c53">1.5.3. <span class="todo TODO">TODO</span> Interacting with the Device File</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org72e1b85" class="outline-2">
<h2 id="org72e1b85"><span class="section-number-2">1</span> Hello <code>chrdev</code></h2>
<div class="outline-text-2" id="text-1">
<p>
A learning module created by simplifying the scull module presented in <a href="https://lwn.net/images/pdf/LDD3/ch03.pdf">chapter 3</a> of <a href="https://lwn.net/Kernel/LDD3/"><i>Linux Device Drivers, Third Edition</i></a>.
</p>

<p>
<code>cat /dev/hello-dev0</code> will output "Hello world" once the module has been loaded. Any user can write to the device to update the greeting like <code>echo -n "Bob" &gt; /dev/hello-dev0</code>.
After which <code>cat /dev/hello-dev0</code> will output "Hello Bob".
</p>
</div>

<div id="outline-container-orgff5707c" class="outline-3">
<h3 id="orgff5707c"><span class="section-number-3">1.1</span> Loading and Unloading the Module</h3>
<div class="outline-text-3" id="text-1-1">
</div>
<div id="outline-container-orgf017051" class="outline-4">
<h4 id="orgf017051"><span class="section-number-4">1.1.1</span> Structs and Macros</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
We need to set up some things so that our "Hello" greeting can have a <code>target</code> other than "world".
</p>

<div class="org-src-container">
<pre class="src src-c" id="orge6f7413"><span style="color: #828997;">#if</span><span style="color: #828997; font-weight: bold;">n</span><span style="color: #828997;">def</span> TARGET_MAX_LEN
<span style="color: #828997;">#define</span> <span style="color: #E06C75;">TARGET_MAX_LEN</span> 64
<span style="color: #828997;">#endif</span>
</pre>
</div>

<p>
<code>TARGET_MAX_LEN</code> is the maximum length of the name we'll store. This <i>could</i> be set up as a load time parameter. However, since how the driver's major version is passed
at load time is an example of a module parameter, a compile time parameter is simpler and sufficient here.
</p>

<div class="org-src-container">
<pre class="src src-c" id="orge40eb5e"><span style="color: #C678DD;">struct</span> <span style="color: #E5C07B;">hello_dev</span> {
  <span style="color: #E5C07B;">char</span> <span style="color: #E06C75;">target</span>[TARGET_MAX_LEN + 1];
  <span style="color: #C678DD;">struct</span> <span style="color: #E5C07B;">cdev</span> <span style="color: #E06C75;">cdev</span>;
};
</pre>
</div>

<p>
The <code>hello_dev</code> struct will be used later to keep the <code>target</code>, initially "world", associated with a specific device. This pattern enables creating multiple devices,
like <code>/dev/hello-dev0</code> and <code>/dev/hello-dev1</code>, that each have independent state. This makes it easier to transition from a single device to multiple devices.
</p>
</div>
</div>

<div id="outline-container-orgabe7f47" class="outline-4">
<h4 id="orgabe7f47"><span class="section-number-4">1.1.2</span> Major Number Parameter</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
Each device has a major and minor number. The major is used by the kernel to determine which driver manages a devices. The minor is used to distinguish devices that
are managed by the same driver. The major and minor numbers can be seen in <code>ls -l /dev/null</code> output.
</p>

<div class="org-src-container">
<pre class="src src-shell">$ ls -l /dev/null
crw-rw-rw- 1 root root 1, 3 Jun 29 17:51 /dev/null
</pre>
</div>

<p>
In this case the major number is 1 and the minor number is 3. We can check in <code>/proc/devices</code> to see what driver manages <code>/dev/null</code>.
</p>

<div class="org-src-container">
<pre class="src src-shell">$ grep <span style="color: #98C379;">" 1 "</span> /proc/devices
 1 mem
</pre>
</div>

<p>
We see that the <code>mem</code> driver handles <code>/dev/null</code> on this system.
</p>

<p>
Using a fixed major number can cause driver conflicts down the road, but being flexible is not without issue. We won't know what the major number is until after the
module is loaded so we can't create nodes in <code>/dev</code> before the module is loaded. The scull driver is not opinionated here. It allows setting the major number at compile 
time or load time and it will get a major number dynamically if one isn't set in advance. To keep things simpler this driver only allows a dynamic major number. We'll 
account for it the same way the <code>scull_load</code> does in <code>hello-dev-load.sh</code>.
</p>

<div class="org-src-container">
<pre class="src src-c" id="org8fecc10"><span style="color: #E5C07B;">int</span> <span style="color: #E06C75;">hello_major</span> = 0;
<span style="color: #E5C07B;">int</span> <span style="color: #E06C75;">hello_minor</span> = 0;
</pre>
</div>

<p>
We'll use these globals to store the major and minor numbers.
</p>
</div>
</div>

<div id="outline-container-org801bfd5" class="outline-4">
<h4 id="org801bfd5"><span class="section-number-4">1.1.3</span> Loading</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
To be useful our driver needs to get a major number and initialize the state for the devices when it is loaded.
</p>

<div class="org-src-container">
<pre class="src src-c" id="org41b9466"><span style="color: #E5C07B;">dev_t</span> <span style="color: #E06C75;">dev</span>;
<span style="color: #E5C07B;">int</span> <span style="color: #E06C75;">result</span> = 0;

result = alloc_chrdev_region(&amp;dev, hello_minor, 1, <span style="color: #98C379;">"hello-dev"</span>);
hello_major = MAJOR(dev);

<span style="color: #C678DD;">if</span> (result &lt; 0) {
  printk(KERN_WARNING <span style="color: #98C379;">"hello: can't get major %d"</span>, hello_major);
  <span style="color: #C678DD;">return</span> result;
}
</pre>
</div>

<p>
To get a major number for our driver we'll call <a href="https://www.kernel.org/doc/htmldocs/kernel-api/API-alloc-chrdev-region.html"><code>alloc_chrdev_region</code></a>, failing if the <code>result</code> of that call is negative.
</p>

<p>
<code>alloc_chrdev_region</code> needs:
</p>
<ol class="org-ol">
<li>A place to store the result. We're using <code>dev_t dev</code>. <code>dev_t</code> is an integer type that represents the major and minor numbers for a device.</li>
<li>The first minor number to use. We've set <code>hello_minor = 0</code> above.</li>
<li>The number of devices to create.</li>
<li>A string name for the driver that will manage the devices. We'll use this later when we check for the major number in <code>/proc/devices</code></li>
</ol>


<p>
The <code>MAJOR</code> macro gets the major number from <code>dev</code> so it can be stored.
</p>

<p>
Now that we've got a major number we can prepare the device!
</p>

<div class="org-src-container">
<pre class="src src-c" id="org4d0dd31"><span style="color: #C678DD;">struct</span> <span style="color: #E5C07B;">hello_dev</span> *<span style="color: #E06C75;">device</span>;
</pre>
</div>

<p>
<code>device</code> gives us a global place to keep track of where the state for devices is in memory. If we were using more than one device we'd use an array of 
<code>struct hello_dev *</code> here instead.
</p>

<div class="org-src-container">
<pre class="src src-c" id="org9a03ddf">device = kmalloc(<span style="color: #C678DD;">sizeof</span>(<span style="color: #C678DD;">struct</span> <span style="color: #E5C07B;">hello_dev</span>), GFP_KERNEL);
<span style="color: #C678DD;">if</span> (<span style="color: #56B6C2; font-weight: bold;">!</span>device) {
  result = -ENOMEM;
 }
<span style="color: #61AFEF;">memset</span>(device, 0, <span style="color: #C678DD;">sizeof</span>(<span style="color: #C678DD;">struct</span> <span style="color: #E5C07B;">hello_dev</span>));
</pre>
</div>

<p>
We allocate some space to store the state using <a href="https://www.kernel.org/doc/htmldocs/kernel-api/API-kmalloc.html"><code>kmalloc</code></a>. We'll have to free it when the module is unloaded. If the allocation fails we'll return a no memory error.
We also make sure to zero the memory out using <code>memset</code> because kernel memory is shared between modules. Zeroing reduces the risk that some secret data will get leaked.
</p>

<p>
<code>kmalloc</code> needs:
</p>
<ol class="org-ol">
<li>The number of bytes to allocate. We need enough to store an instance of <code>struct hello_dev</code>.</li>
<li>The type of memory to allocate. All we need for now is normal kernel ram.</li>
</ol>


<div class="org-src-container">
<pre class="src src-c" id="orgf5eccae"><span style="color: #C678DD;">struct</span> <span style="color: #E5C07B;">file_operations</span> <span style="color: #E06C75;">hello_fops</span> = {
  .owner = THIS_MODULE,
  .read = hello_read,
  .write = hello_write,
  .open = hello_open,
  .release = hello_release,
};
</pre>
</div>

<p>
We'll implement these functions later so that our driver can provide read and write capability.
</p>

<div class="org-src-container">
<pre class="src src-c" id="org626f96a">cdev_init(&amp;device-&gt;cdev, &amp;hello_fops);
device-&gt;cdev.owner = THIS_MODULE;
device-&gt;cdev.ops = &amp;hello_fops;
</pre>
</div>

<p>
We set the device up by initializing it with <a href="https://www.kernel.org/doc/htmldocs/kernel-api/API-cdev-init.html"><code>cdev_init</code></a> since we're embedding a <code>struct cdev</code> in the <code>struct hello_dev</code>. Once initalized we set the <code>owner</code> and point
<code>ops</code> at a <code>struct file_operations</code> which points at functions to call for things like reading and writing from the device. <code>THIS_MODULE</code> is a kernel macro that points
to the running module.
</p>

<p>
<code>cdev_init</code> needs:
</p>
<ol class="org-ol">
<li>A pointer to the memory to initalize. We're using <code>cdev</code> on <code>device</code>.</li>
<li>A pointer to the file operations. We're using <code>&amp;hello_fops</code> (the functions will be defined later).</li>
</ol>


<div class="org-src-container">
<pre class="src src-c" id="org3dd267e"><span style="color: #E5C07B;">char</span> *<span style="color: #E06C75;">default_target</span> = <span style="color: #98C379;">"world"</span>;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c" id="orgff2f0ae"><span style="color: #61AFEF;">memcpy</span>(device-&gt;target, default_target, <span style="color: #E5C07B;">strlen</span>(<span style="color: #E06C75;">default_target</span>));
</pre>
</div>

<p>
We set up the default target of the greeting by copying it into the recently allocated space for <code>device</code> using <code>memcpy</code>.
</p>

<div class="org-src-container">
<pre class="src src-c" id="orgc626229"><span style="color: #E5C07B;">int</span> <span style="color: #E06C75;">error</span>;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c" id="org64c5a90">error = cdev_add(&amp;device-&gt;cdev, dev, 1);
<span style="color: #C678DD;">if</span> (error) {
  printk(KERN_NOTICE <span style="color: #98C379;">"Error %d adding hello%d"</span>, error, dev);
}
</pre>
</div>

<p>
Finally we can add the device using <a href="https://www.kernel.org/doc/htmldocs/kernel-api/API-cdev-add.html"><code>cdev_add</code></a>, logging a message if there is any problem.
</p>

<p>
<code>cdev_add</code> needs:
</p>
<ol class="org-ol">
<li>A pointer to the device to add. We're using the <code>cdev</code> which was recently initalized on <code>device</code>.</li>
<li>The first device number this driver handles. <code>dev</code> is set to this early on during module loading.</li>
<li>The number of minor numbers to add for this driver. We're only using a single device so 1 is fine.</li>
</ol>


<div class="org-src-container">
<pre class="src src-c" id="org587ae21"><span style="color: #61AFEF;">module_init</span>(hello_init);
</pre>
</div>

<p>
We wrap this loading functionality up in <code>static int hello_init(void)</code> and use <a href="https://www.kernel.org/doc/htmldocs/kernel-hacking/routines-init-again.html"><code>module_init</code></a> to tell the kernel how to load the module.
</p>
</div>
</div>

<div id="outline-container-org907b85d" class="outline-4">
<h4 id="org907b85d"><span class="section-number-4">1.1.4</span> Unloading</h4>
<div class="outline-text-4" id="text-1-1-4">
<p>
Unloading this module is a bit simpler. We have to free the memory we allocated and unregister the driver.
</p>

<div class="org-src-container">
<pre class="src src-c" id="orgadb75f5"><span style="color: #61AFEF;">kfree</span>(device);
</pre>
</div>

<p>
Memory is freed using <a href="https://www.kernel.org/doc/htmldocs/kernel-api/API-kfree.html"><code>kfree</code></a> which needs a pointer that was returned by <code>kmalloc</code>. We're using <code>device</code> which was allocated when the module was loaded.
</p>

<div class="org-src-container">
<pre class="src src-c" id="orgf4f7b1f"><span style="color: #E5C07B;">dev_t</span> <span style="color: #E06C75;">dev_num</span> = MKDEV(hello_major, hello_minor);
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c" id="org69024c3"><span style="color: #61AFEF;">unregister_chrdev_region</span>(dev_num, 1);
</pre>
</div>

<p>
We use <a href="https://www.kernel.org/doc/htmldocs/kernel-api/API-unregister-chrdev-region.html"><code>unregister_chrdev_region</code></a> to release the device we allocated with <code>alloc_chrdev_region</code> when the module was loaded.
</p>

<p>
<code>unregister_chrdev_region</code> needs:
</p>
<ol class="org-ol">
<li>The first device number in the region. We're using <code>MKDEV</code> to build that based on <code>hello_major</code> and <code>hello_minor</code>.</li>
<li>The number of devices. We allocated one when the module was loaded.</li>
</ol>


<div class="org-src-container">
<pre class="src src-c" id="org5a8cf0a"><span style="color: #61AFEF;">module_exit</span>(hello_exit);
</pre>
</div>

<p>
We wrap this up in <code>static void hello_exit(void)</code> and use <a href="https://www.kernel.org/doc/htmldocs/kernel-hacking/routines-moduleexit.html"><code>module_exit</code></a> to let the kernel know how to unload the module.
</p>
</div>
</div>
</div>

<div id="outline-container-org0967ab0" class="outline-3">
<h3 id="org0967ab0"><span class="section-number-3">1.2</span> Opening and Closing a Device</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-org4ffaed9" class="outline-4">
<h4 id="org4ffaed9"><span class="section-number-4">1.2.1</span> Opening</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
A more sophisticated driver might have multiple devices and need to know which one is being opened. The open function is passed a <code>struct inode *</code> which contians a pointer
to <code>cdev</code> on <code>device</code>. If we managed more than one device we'd use <a href="https://www.kernel.org/doc/html/latest/driver-api/driver-model/design-patterns.html#container-of"><code>container_of</code></a> to determine <i>which</i> device in our array of <code>struct hello_dev</code> was being opened. Once we 
have a pointer to a <code>struct hello_dev</code> it can be placed in <code>struct file</code>'s <code>private_data</code> so that read and write functions have access to the device state.
</p>

<div class="org-src-container">
<pre class="src src-c" id="org4affb47"><span style="color: #C678DD;">if</span> ((f-&gt;f_flags &amp; O_ACCMODE) == O_WRONLY) {
  memset(device-&gt;target, 0, TARGET_MAX_LEN + 1);
}
</pre>
</div>

<p>
This module doesn't have much setup to do on open. If the device file was opened write only then we zero out the <code>target</code> in anticipation of new data. We wrap it up in a
<code>int hello_open (struct inode *i, struct file *f)</code> so it matches what <code>struct file_operations</code> expects.
</p>
</div>
</div>

<div id="outline-container-orgd929f89" class="outline-4">
<h4 id="orgd929f89"><span class="section-number-4">1.2.2</span> Closing</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
Easy setup makes for easy cleanup. There would be more to consider on the release side if the driver was more sophisticated.
</p>

<div class="org-src-container">
<pre class="src src-c" id="org96e92eb"><span style="color: #E5C07B;">int</span> <span style="color: #61AFEF;">hello_release</span>(<span style="color: #C678DD;">struct</span> <span style="color: #E5C07B;">inode</span> *<span style="color: #E06C75;">i</span>, <span style="color: #C678DD;">struct</span> <span style="color: #E5C07B;">file</span> *<span style="color: #E06C75;">f</span>) {
  <span style="color: #C678DD;">return</span> 0;
}
</pre>
</div>

<p>
The function signature must match what is expected by <code>struct file_operations</code> like it does for <code>hello_open</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-orgc51929f" class="outline-3">
<h3 id="orgc51929f"><span class="section-number-3">1.3</span> Reading and Writing Devices</h3>
<div class="outline-text-3" id="text-1-3">
</div>
<div id="outline-container-org81366d3" class="outline-4">
<h4 id="org81366d3"><span class="section-number-4">1.3.1</span> Reading</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
Our goal when reading from the device is to output a greeting like "Hello world" or an updated greeting if someone has written a new <code>target</code> to the device.
</p>

<p>
Our read function will be called by the kernel when someone tries to read from our device file. The kernel will pass us a <code>struct file *</code> so we can determine which
device is being read from. If the driver were more sophisticated we would have made the <code>private_data</code> field of the <code>file</code> struct a pointer to our <code>device</code>. That way we'd
be able to access any state we had stored for the device. Since this driver only manages one device we can skip that detail.
</p>

<div class="org-src-container">
<pre class="src src-c" id="org7ab9c2e"><span style="color: #E5C07B;">char</span> <span style="color: #E06C75;">data</span>[72] = <span style="color: #98C379;">"Hello "</span>;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c" id="org07d3197"><span style="color: #61AFEF;">memcpy</span>(data + strlen(data), device-&gt;target, strlen(device-&gt;target));
</pre>
</div>

<p>
We build up our greeting string so that it can be copied into user memory later.
</p>

<div class="org-src-container">
<pre class="src src-c" id="orgef02bc5"><span style="color: #E5C07B;">long</span> <span style="color: #E06C75;">leftover</span>, <span style="color: #E06C75;">transferred</span>, <span style="color: #E06C75;">remaining_bytes</span>;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c" id="orga257dc1">remaining_bytes = strlen(data) - *offset;
<span style="color: #C678DD;">if</span> (remaining_bytes &lt;= 0) {
  transferred = 0;
} <span style="color: #C678DD;">else</span> <span style="color: #C678DD;">if</span> (read_amount &gt; remaining_bytes) {
  leftover = copy_to_user(buf, data + *offset, remaining_bytes);
  transferred = remaining_bytes - leftover;
} <span style="color: #C678DD;">else</span> {
  leftover = copy_to_user(buf, data + *offset, read_amount);
  transferred = read_amount - leftover;
}
</pre>
</div>

<p>
When our read function is called it'll get the amount of data the caller is prepared to read as a <code>size_t</code> and an <code>loff_t *</code> that specifies the offset before the read. We'll
update that offset after data is copied to user memory. 
</p>

<p>
Before we go copying from kernel memory to user memory we need to check a couple things:
</p>
<ol class="org-ol">
<li>Are there bytes left to read?
<ol class="org-ol">
<li>If not don't transfer anything to user memory</li>
</ol></li>
<li>Is the amount of data requested greater than the amount of data we have to read? 
<ol class="org-ol">
<li>If so attempt to transfer all the remaining data</li>
</ol></li>
<li>Otherwise the offset must be before the end of readable data and the amount of data requested must be less than the amount that can be read
<ol class="org-ol">
<li>Attempt to transfer all the requested bytes from kernel memory to user memory</li>
</ol></li>
</ol>

<p>
We can't directly copy from kernel memory to user memory. Instead we need to use <a href="https://www.kernel.org/doc/html/v4.16/kernel-hacking/hacking.html#copy-to-user-copy-from-user-get-user-put-user"><code>copy_to_user</code></a> to move data around.
</p>

<p>
<code>copy_to_user</code> needs:
</p>
<ol class="org-ol">
<li>A destination pointer in user memory</li>
<li>A source pointer in kernel memory</li>
<li>How many bytes to copy</li>
</ol>


<div class="org-src-container">
<pre class="src src-c" id="org91d49c7">*offset = *offset + transferred;

<span style="color: #C678DD;">return</span> transferred;
</pre>
</div>

<p>
Advance the offset based on how much data was successfully transferred. The function is also expected to return how much data was successfully moved.
</p>

<p>
Wrap the read logic up in <code>ssize_t hello_read(struct file *f, char __user *buf, size_t read_amount, loff_t *offset)</code> so that it can be used in a <code>file_operations</code> struct.
The <code>__user</code> on <code>char __user *buf</code> lets us know that the pointer is in user memory, not kernel memory.
</p>
</div>
</div>

<div id="outline-container-org970cc72" class="outline-4">
<h4 id="org970cc72"><span class="section-number-4">1.3.2</span> Writing</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
The goal of writing to the device is to update the <code>target</code> of the greeting. This is where <code>echo "Bob" &gt; /dev/hello-dev0</code> is able to update the device's state.
</p>

<div class="org-src-container">
<pre class="src src-c" id="org05ff628"><span style="color: #E5C07B;">long</span> <span style="color: #E06C75;">leftover</span>, <span style="color: #E06C75;">transferred</span>, <span style="color: #E06C75;">remaining_bytes</span>;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c" id="org33b6fe6">remaining_bytes = TARGET_MAX_LEN - *offset;
<span style="color: #C678DD;">if</span> (remaining_bytes &lt;= 0) {
  transferred = 0;
} <span style="color: #C678DD;">else</span> <span style="color: #C678DD;">if</span> (write_amount &gt; remaining_bytes) {
  leftover = copy_from_user(device-&gt;target + *offset, buf, remaining_bytes);
  transferred = write_amount - leftover;
} <span style="color: #C678DD;">else</span> {
  leftover = copy_from_user(device-&gt;target + *offset, buf, write_amount);
  transferred = write_amount - leftover;
}
</pre>
</div>

<p>
Similar to the read function we'll get <code>write_amount</code>, which represents the desired number of bytes to write, and a pointer to an <code>offset</code>, which represents how
many bytes into the data to start the write. We have to make sure to prevent writes that would be out of bounds either because the <code>offset</code> is past the end of our
data's allocated memory or because the <code>write_amount</code> is greater than the space we have for writing.
</p>

<p>
To determine how much space can still be written we subtract the desired offset from the number of bytes we have allocated.
</p>

<p>
Our checks look like:
</p>
<ol class="org-ol">
<li>Is there any space left for writing?
<ol class="org-ol">
<li>If not don't transfer anything</li>
</ol></li>
<li>Is the amount of data to be written bigger than the space we have for writing?
<ol class="org-ol">
<li>If so attempt to transfer as much as we can from user memory to kernel memory and ignore the rest
<ol class="org-ol">
<li>We'll lie a little bit here and tell the caller that all the requested data was written, minus anything <code>copy_from_user</code> missed, so that the caller won't
keep trying to write data that won't fit.</li>
</ol></li>
</ol></li>
<li>Otherwise we must have room to write to and the offset is in bounds
<ol class="org-ol">
<li>Attempt to transfer all the data from user memory to kernel memory</li>
</ol></li>
</ol>


<p>
<code>copy_from_user</code> is similar to <code>copy_to_user</code> and we use it for the same reason. We can't directly copy from user memory to kernel memory for a variety of reasons.
</p>

<div class="org-src-container">
<pre class="src src-c" id="org9f55efa">*offset = *offset + transferred;
<span style="color: #C678DD;">return</span> transferred;
</pre>
</div>

<p>
Just like read has to advance the offset after reading we have to advance the offset after writing. We're also expected to return the number of bytes written.
</p>

<p>
We wrap up the write logic in <code>ssize_t hello_write(struct file *f, const char __user *buf, size_t write_amount, loff_t *offset)</code> so it works for a 
<code>file_operations</code> struct.
</p>
</div>
</div>
</div>

<div id="outline-container-orgdadf6be" class="outline-3">
<h3 id="orgdadf6be"><span class="section-number-3">1.4</span> <span class="todo TODO">TODO</span> Building the Module</h3>
<div class="outline-text-3" id="text-1-4">
</div>
<div id="outline-container-org83fbfda" class="outline-4">
<h4 id="org83fbfda"><span class="section-number-4">1.4.1</span> <span class="todo TODO">TODO</span> <code>Makefile</code></h4>
</div>
</div>
<div id="outline-container-org81f40e2" class="outline-3">
<h3 id="org81f40e2"><span class="section-number-3">1.5</span> <span class="todo TODO">TODO</span> Using It!</h3>
<div class="outline-text-3" id="text-1-5">
</div>
<div id="outline-container-orgf784eb6" class="outline-4">
<h4 id="orgf784eb6"><span class="section-number-4">1.5.1</span> <span class="todo TODO">TODO</span> <code>hello-dev-load.sh</code></h4>
</div>
<div id="outline-container-orge7b4fcb" class="outline-4">
<h4 id="orge7b4fcb"><span class="section-number-4">1.5.2</span> <span class="todo TODO">TODO</span> <code>hello-dev-unload.sh</code></h4>
</div>
<div id="outline-container-org9163c53" class="outline-4">
<h4 id="org9163c53"><span class="section-number-4">1.5.3</span> <span class="todo TODO">TODO</span> Interacting with the Device File</h4>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Frank Burnham</p>
<p class="date">Created: 2022-07-11 Mon 08:09</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
